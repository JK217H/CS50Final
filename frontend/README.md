To-Do-Webbi
#### Video Demo:  <https://youtu.be/mvQxVrhngF4# >
#### Description:
It is a Web-App to-do-list app. This project is more focused on functionality than design since this was the part I really wanted to improve on. You have 5 main pages: the home page with a to-do list for the current day and a form where you can add a new task. A task has a title (mandatory) and can, on top of that, have a description, tag, and/or date. After a task is finished, it gets to the closed tag list. Then you have the projects page, in which you can group tasks together under 4 capital letter tags, which helps organize tasks better. Then, on the calendar page, you can click on any random day throughout the year and check what tasks you have to do on that day. The next part is a general task collector, which shows all tags no matter the date or description, and also all the completed tasks as a history to see all of what you did. The last page is an editor which lets you change each aspect of a task, delete a task, and/or change or delete a projecttag. When a projecttag is deleted or changed, it will be updated/removed for all tasks that had this tag. I used vue.js for the front end on this page and flask/python for the backend for this page. I decided to do this because vue.js is supposed to be more beginner-friendly than react, and I used python/flask and sqlite3 for the database because I really liked using it during the course. For the minimal styling I did, I started to experiment with tailwind; hence, I really liked the ability to instantly apply the styling easily via a class system, which is quite intuitive. I split my folder into a frontend and a backend part. The frontend part contains the vue components, the css, the viewpages, and the router. In the app.vue page, meaning in the general foundation of the page, I have the navbar component (a component which lets you click from each page to each page at the top of the webpage) and the routerview component, which basically makes this a single-file-application page. I then have 5 components for each of the pages. One for the to-do_list (main page), in which there is a form to add a task to the tasks database, and I am fetching for the tasks of the current day via axios and also posting tasks to the table tasks via axios. Now onto the projects component, in which I am again using axios to fetch for and post the tags into the project_tags table. Furthermore, under the tag creation is a list which displays all the projecttags and the tasks that belong to it. The next component is the calendar component, in which I am using css to style the calendar, and an unordered list shows up when clicking on a specific day to show the tasks for it. If there are no tasks, a message will display that there are no tasks for this day. The next component is the task collector, in which there are two tables: one for the tasks which are yet to be finished and one for the tasks which have been finished. The last component is the editor, in which you can change or delete a task via a form and delete and edit each projecttag, which will be updated in the database again.
Now for the backend: I used flask and python to create all the different app routes to fetch from, and also a database which contains two tables which save the tags as well as the tasks. I decided to do it this way so that the tasks would be stored from session to session and that they wouldn't be just stored temporarily and be gone after reloading the browser. Most of the routes follow the similar principle of creating a database connection and then using this to get the data from the database. Most of the work here was getting the correct routes and using the right sql commands.
Now, to dig more into tailwind, I decided to not go too deep with the css for this project because I was really losing my motivation, and css can get quite tedious for webpage layout etc., which is why I will tackle that in another future project. I decided to do this project because I am a big user of to-do-lists and wanted to understand the logic behind and how they would work in a web app.